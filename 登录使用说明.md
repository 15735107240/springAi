# 登录使用说明

## 概述

系统采用手机号 + 6位验证码的登录方式，使用 OAuth2.0 协议生成 JWT 格式的访问令牌。登录成功后，可以通过 `UserContext` 工具类在后台代码中直接获取当前登录用户信息。

## API 接口

### 1. 获取验证码

**接口：** `POST /api/auth/code`

**请求体：**
```json
{
    "phoneNumber": "15735107240"
}
```

**响应：**
```json
{
    "success": true,
    "message": "验证码已发送",
    "phoneNumber": "157****7240",
    "code": "123456"
}
```

**字段说明：**
- `phoneNumber`：脱敏后的手机号（中间4位用 `****` 替代）
- `code`：验证码（**仅用于开发测试，生产环境应移除**）

**注意事项：**
- 验证码有效期为 5 分钟
- 验证码发送有冷却期，默认 60 秒内不能重复发送
- 手机号格式：11位数字，1开头（如：`15735107240`）

---

### 2. 登录

**接口：** `POST /api/auth/login`

**请求体：**
```json
{
    "phoneNumber": "15735107240",
    "code": "123456"
}
```

**响应：**
```json
{
    "success": true,
    "message": "登录成功",
    "accessToken": "eyJraWQiOiJhMjM1NTI5ZC02YzQ5LTRlYWYtODMyYy1iNTY0ZTUzMzVmNjci...",
    "tokenType": "Bearer",
    "expiresIn": 3600
}
```

**字段说明：**
- `accessToken`：JWT 格式的访问令牌，用于访问受保护的资源（有效期 1 小时）
- `tokenType`：令牌类型，固定为 `"Bearer"`
- `expiresIn`：访问令牌过期时间（秒），默认 3600 秒（1 小时）

**JWT 令牌包含的 Claims：**
- `sub`：客户端 ID（`spring-ai-client`）
- `username`：用户手机号
- `phone_number`：用户手机号
- `iss`：颁发者（`http://localhost:10010`）
- `exp`：过期时间
- `iat`：签发时间

---

### 3. 获取当前用户信息

**接口：** `GET /api/auth/user`

**请求头：**
```
Authorization: Bearer {accessToken}
```

**响应：**
```json
{
    "success": true,
    "message": "获取用户信息成功",
    "user": {
        "phoneNumber": "157****7240",
        "username": "user_7240",
        "enabled": true
    }
}
```

**字段说明：**
- `phoneNumber`：脱敏后的手机号
- `username`：用户名（默认为手机号）
- `enabled`：账号是否启用

---

## 使用示例

### cURL

```bash
# 1. 获取验证码
curl -X POST http://localhost:10010/api/auth/code \
  -H "Content-Type: application/json" \
  -d '{"phoneNumber": "15735107240"}'

# 2. 登录获取 Token（将返回的 code 替换到下面的请求中）
curl -X POST http://localhost:10010/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "phoneNumber": "15735107240",
    "code": "123456"
  }'

# 3. 获取当前用户信息（将返回的 accessToken 替换到下面的请求中）
curl -X GET http://localhost:10010/api/auth/user \
  -H "Authorization: Bearer eyJraWQiOiJhMjM1NTI5ZC02YzQ5LTRlYWYtODMyYy1iNTY0ZTUzMzVmNjci..."

# 4. 使用访问令牌访问受保护资源
curl -X GET http://localhost:10010/api/history/15735107240 \
  -H "Authorization: Bearer eyJraWQiOiJhMjM1NTI5ZC02YzQ5LTRlYWYtODMyYy1iNTY0ZTUzMzVmNjci..."
```

### JavaScript (Fetch API)

```javascript
// 1. 获取验证码
const codeResponse = await fetch('http://localhost:10010/api/auth/code', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    phoneNumber: '15735107240'
  })
});
const codeData = await codeResponse.json();
console.log('验证码:', codeData.code);

// 2. 登录
const loginResponse = await fetch('http://localhost:10010/api/auth/login', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    phoneNumber: '15735107240',
    code: codeData.code
  })
});
const loginData = await loginResponse.json();
const accessToken = loginData.accessToken;
console.log('访问令牌:', accessToken);

// 3. 获取用户信息
const userResponse = await fetch('http://localhost:10010/api/auth/user', {
  headers: {
    'Authorization': `Bearer ${accessToken}`
  }
});
const userData = await userResponse.json();
console.log('用户信息:', userData.user);
```

---

## 登录流程

1. **获取验证码**：调用 `POST /api/auth/code` 获取验证码
2. **获取 Token**：调用 `POST /api/auth/login` 使用验证码登录，获取访问令牌
3. **获取用户信息**：调用 `GET /api/auth/user` 使用访问令牌获取当前用户信息
4. **访问受保护资源**：在请求头中添加 `Authorization: Bearer {accessToken}` 访问受保护的资源

---

## 后台获取当前用户信息

### 方式一：使用 UserContext 工具类（推荐）

`UserContext` 使用 ThreadLocal 存储当前登录用户信息，无需注入依赖，直接在代码中调用静态方法即可。

**在 Controller 中使用：**
```java
import com.springai.auth.context.UserContext;

@RestController
@RequestMapping("/api/example")
public class ExampleController {
    
    @GetMapping("/info")
    public String getInfo() {
        // 获取当前用户
        User user = UserContext.getUser();
        if (user == null) {
            throw new BusinessException("未登录");
        }
        
        // 获取当前用户手机号
        String phoneNumber = UserContext.getPhoneNumber();
        
        // 检查是否已登录
        if (UserContext.isAuthenticated()) {
            return "用户已登录：" + phoneNumber;
        }
        
        return "用户未登录";
    }
}
```

**在 Service 中使用：**
```java
import com.springai.auth.context.UserContext;

@Service
public class ExampleService {
    
    public void doSomething() {
        // 获取当前登录用户
        User user = UserContext.getUser();
        String phoneNumber = UserContext.getPhoneNumber();
        
        // 业务逻辑...
    }
}
```

**UserContext 提供的方法：**
- `UserContext.getUser()`：获取当前用户对象（`User` 类型）
- `UserContext.getPhoneNumber()`：获取当前用户手机号（`String` 类型）
- `UserContext.isAuthenticated()`：检查当前用户是否已登录（`boolean` 类型）
- `UserContext.clear()`：清除当前用户上下文（内部使用，无需手动调用）

### 方式二：使用 CurrentUserService

也可以通过注入 `CurrentUserService` 来获取当前登录用户信息：

```java
import com.springai.auth.service.CurrentUserService;

@Service
public class ExampleService {
    
    private final CurrentUserService currentUserService;
    
    public ExampleService(CurrentUserService currentUserService) {
        this.currentUserService = currentUserService;
    }
    
    public void doSomething() {
        // 获取当前用户手机号
        String phoneNumber = currentUserService.getCurrentPhoneNumber();
        
        // 获取当前完整用户信息
        User user = currentUserService.getCurrentUser();
        
        // 检查是否已登录
        boolean authenticated = currentUserService.isAuthenticated();
    }
}
```

> **推荐使用方式一**：`UserContext` 工具类更简洁，无需注入依赖，代码更清晰。

---

## 工作原理

### UserContext 自动填充机制

1. **UserContextFilter 过滤器**：在每个请求开始时自动执行
2. **从 SecurityContext 提取用户信息**：通过 JWT 令牌解析用户信息
3. **存储到 ThreadLocal**：将用户信息存储到 `UserContext` 的 ThreadLocal 中
4. **请求结束时自动清理**：在 `finally` 块中清除 ThreadLocal，避免内存泄漏

### 安全机制

- **JWT 令牌验证**：所有受保护的资源都需要有效的 JWT 令牌
- **自动过期**：访问令牌有效期为 1 小时，过期后需要重新登录
- **线程隔离**：每个请求使用独立的 ThreadLocal，确保用户信息不会相互干扰

---

## 错误处理

### 常见错误及解决方案

#### 1. "未找到注册的 OAuth2 客户端"

**原因：** Redis 中缺少客户端配置

**解决方案：**
```bash
# 清理 Redis 中的旧数据
redis-cli DEL oauth2:client:clientId:spring-ai-client
redis-cli DEL oauth2:client:index

# 重启应用，@PostConstruct 会自动创建客户端配置
```

#### 2. "验证码错误或已过期"

**原因：**
- 验证码输入错误
- 验证码已过期（5分钟）
- 验证码已使用过

**解决方案：** 重新获取验证码并登录

#### 3. "手机号格式不正确"

**原因：** 手机号不符合格式要求

**格式要求：** 11位数字，1开头（如：`15735107240`）

#### 4. "未登录或登录已过期"

**原因：**
- 未提供访问令牌
- 访问令牌已过期
- 访问令牌无效

**解决方案：** 重新登录获取新的访问令牌

---

## 注意事项

1. **令牌有效期**：访问令牌有效期为 1 小时，过期后需要重新登录
2. **验证码有效期**：验证码有效期为 5 分钟，过期后需要重新获取
3. **验证码冷却期**：验证码发送有 60 秒的冷却期，避免频繁发送
4. **安全建议**：
   - 生产环境应移除响应中的 `code` 字段
   - 始终使用 HTTPS 传输令牌
   - 不要将令牌包含在 URL 参数中
   - 令牌应安全存储（使用 `httpOnly` Cookie 或安全的本地存储）
   - 定期刷新访问令牌（如果实现了刷新令牌机制）

---

## 技术实现

### 认证流程

1. **验证码生成**：使用 Redis 存储验证码，设置 5 分钟过期时间
2. **用户创建**：登录时自动创建用户（如果不存在），存储在 Redis 中
3. **令牌生成**：使用 OAuth2.0 CLIENT_CREDENTIALS 流程生成 JWT 令牌
4. **用户上下文**：通过 `UserContextFilter` 自动填充 `UserContext`

### 存储结构

- **验证码**：`sms:code:{phoneNumber}` - 存储验证码，5 分钟过期
- **用户信息**：`user:phone:{phoneNumber}` - 存储用户信息，30 天过期
- **OAuth2 客户端**：`oauth2:client:clientId:{clientId}` - 存储客户端配置，30 天过期
- **OAuth2 授权**：`oauth2:authorization:{authorizationId}` - 存储授权信息，1 小时过期

---

## 相关文档

- [清理 Redis 客户端配置](./清理Redis客户端.md)
